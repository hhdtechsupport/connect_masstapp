<?php
/**
 * @file
 * Notify roles for Workfllow state transitions.
 */

/**
 * Implements hook_permission().
 */
function workflow_notify_permission() {
  return array(
    'workflow notify' => array(
      'title' => t('Receive workflow notifications'),
      'description' => t('The user may be notified of a workflow state change.'),
      ),
    );
}

/**
 * Implements hook_help().
 */
function workflow_notify_help($path, $arg) {
  switch ($path) {
    case 'admin/config/workflow/workflow/notify/%':
      return '<p>' . t('The selected roles will be notified of each state change selected.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function workflow_notify_menu() {
  $items = array();

  $items['admin/config/workflow/workflow/notify/%workflow'] = array(
    'title' => 'Notifications',
    'access arguments' => array('administer workflow'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workflow_notify_settings_form', 5),
    'type' => MENU_CALLBACK,
    'file' => 'workflow_notify.admin.inc',
    );

  return $items;
} /* */

/**
 * Implements hook_theme().
 */
function workflow_notify_theme() {
  return array(
    'workflow_notify_settings_form' => array(
      'render element' => 'form',
      'file' => 'workflow_notify.admin.inc',
      ),
    );
}

/**
 * Implements hook_hook_info().
 */
function workflow_notify_hook_info() {
  $hooks['workflow_notify'] = array(
    'group' => 'workflow',
  );
  return $hooks;
}

/**
 * Implements hook_workflow_operations().
 * Add an action link to this module.
 */
function workflow_notify_workflow_operations($op, $workflow = NULL) {
  switch ($op) {
    case 'workflow':
      $actions = array(
        'workflow_notify_settings' => array(
          'title' => t('Notifications'),
          'href' => "admin/config/workflow/workflow/notify/$workflow->wid",
          'attributes' => array('alt' => t('Notify users about state changes.')),
          ),
        );

      $actions['workflow_notify_settings']['attributes']['title'] =
        $actions['workflow_notify_settings']['attributes']['alt'];

      return $actions;
  }
}

/**
 * Implements hook_entity_insert().
 * Sene emails on workflow state transitions.
 */
function workflow_notify_entity_insert($entity, $type) {
  if ($type == 'node' && isset($entity->workflow_transitions)) {
    _workflow_notify_send_notification($entity);
  }
}

/**
 * Implements hook_entity_update().
 * Sene emails on workflow state transitions.
 */
function workflow_notify_entity_update($entity, $type) {
  if ($type == 'node' && isset($entity->workflow_transitions)) {
    // Check if there is actually a state change.
    if ($entity->workflow_transitions['field_workflow_state']->new_sid <>
      $entity->workflow_transitions['field_workflow_state']->old_sid) {
      _workflow_notify_send_notification($entity);
    }
  }
}

/**
 * React to a transition after it's done.
 */
function _workflow_notify_send_notification($node) {
  global $user;
  // See if this is a state that we notify for.
  $notify = variable_get('workflow_notify_roles', array());

  // Get the new state from the transition object.
  // @TODO: It could be possible to have more than one transition object?
  // foreach ($node->workflow_transitions as $field_name => $transition).
  $transition = array_pop($node->workflow_transitions);
  $new_state = $transition->new_sid;

  if (isset($notify[$new_state])) {
    // Okay, we are notifying someone of this change.
    // So let's get the workflow object.
    $workflow = workflow_get_workflows_by_type($node->type, 'node');

    // Get the specific roles to notify.
    $notify = $notify[$new_state];

    // See if we want to notify the author too?
    $notify_author = in_array(-1, $notify);
    unset($notify[-1]);

    // There could be no roles set.
    if ($notify) {
      // Get all the user accounts in those roles.
      $query = "SELECT DISTINCT ur.uid FROM {users_roles} ur "
        . "INNER JOIN {users} u ON u.uid = ur.uid "
        . "WHERE ur.rid IN (:rids) AND u.status = 1 ";
      $users = db_query($query, array(':rids' => $notify))->fetchCol();
    }
    else {
      $users = array();
    }

    // Add the author back in, if needed.
    if ($notify_author) {
      $users[] = $node->uid;
    }

    // Load all the user entities, making sure there are no duplicates.
    $accounts = entity_load('user', array_unique($users, SORT_NUMERIC));

    // Call all modules that want to limit the list.
    $args = array(
      'users' => $accounts,
      'node' => $node,
      'state' => $new_state,
      'roles' => $notify,
      'workflow' => $workflow,
      );
    foreach (module_implements('workflow_notify') as $module) {
      $function = $module . '_workflow_notify';
      $function('users', $args);
    }

    // Retrieve the remaining list without duplicates.
    $accounts = $args['users'];
    $addr_list = array();

    // Just quit if there are no users.
    if (empty($accounts)) {
      watchdog('workflow_notify', 'No recipients - email skipped.', array(),
        WATCHDOG_DEBUG, l(t('view'), 'node/' . $node->nid));
      return;
    }

    foreach ($accounts as $uid => $account) {
      $addr_list[] = format_username($account) . '<' . $account->mail . '>';
    }

    $params = array(
      'clear' => TRUE,
      'sanitize' => FALSE,
      'data' => array(
        'node' => $node,
        'user' => $user,
        ),
      'filter' => variable_get('workflow_notify_filter_format_' . $workflow->wid, 'filtered_html'),
      'callback' => 'workflow_notify_token_callback',
      );

    // Build the subject and body of the mail.
    // Token replacement occurs in hook_mail().
    // @TODO: Currently no translation occurs.
    $params['context']['subject'] = variable_get("workflow_notify_subject_$new_state",
      '[node:title] is now "[workflow:workflow-current-state-name]"');

    $params['context']['body'] = variable_get("workflow_notify_body_$new_state",
      '<a href="[node:url:absolute]">[node:title]</a> is now "@state".');

    switch (variable_get('workflow_notify_from_address_' . $workflow->wid, 'site')) {
      case 'site':
        $from = variable_get('site_mail', ini_get('sendmail_from'));
        break;

      case 'changer':
        $from = $user->mail;
        break;
    }

    // Send the email.
    drupal_mail('workflow_notify',
      'workflow_notify',
      implode(';', $addr_list),
      language_default(),
      $params,
      $from);
  }
}

/**
 * Token_replace callback.
 * For some strange reason, sometimes the workflow state is empty.
 */
function workflow_notify_token_callback(&$replacements, $data, $options) {
  if (isset($replacements['[node:field_workflow_state:new-state:label]'])
  && empty($replacements['[node:field_workflow_state:new-state:label]'])) {
    $replacements['[node:field_workflow_state:new-state:label]'] =
      workflow_get_sid_label($data['node']->field_workflow_state[LANGUAGE_NONE][0]['value']);
  }
}

/**
 * Implements hook_mail();
 * Build email messages.
 */
function workflow_notify_mail($key, &$message, $params) {
  switch ($key) {
    case 'workflow_notify':
      $filter = $params['filter'];
      $message['send'] = TRUE;
//      dpm(token_replace($params['context']['body'], $params['data'], $params), 'body token replace');

      $message['subject'] = filter_xss(token_replace($params['context']['subject'],
        $params['data'], $params));
      $message['body'][] = check_markup(token_replace($params['context']['body'],
        $params['data'], $params), $filter);
      return;
  }
}
